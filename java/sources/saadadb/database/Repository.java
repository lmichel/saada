package saadadb.database;

import java.io.File;
import java.io.IOException;
import java.util.Date;

import saadadb.collection.Category;
import saadadb.collection.SaadaOID;
import saadadb.compat.Files;
import saadadb.exceptions.FatalException;
import saadadb.exceptions.SaadaException;
import saadadb.util.CopyFile;
import saadadb.util.Messenger;

/** * @version $Id$

 * some utilities handling repository files.
 * @author michel
 * @version $Id$
 * 07/2011: method sweepReportDir + getUserReportsPath
 * 09/2015: Management of files marking the obsolescence of either cache meta or cache VO
 */
public class Repository {
	private static String separ = System.getProperty("file.separator");
	/*
	 * Repository subdirs
	 */
	public static final String VOREPORTS      = "voreports";
	public static final String TMP            = "tmp";
	public static final String LOGS           = "logs";
	public static final String INDEXRELATIONS = "indexrelations";
	public static final String EMBEDDEDDB     = "embeddeddb";
	public static final String DMS     	      = "dms";
	public static final String CONFIG     	  = "config";
	public static final String OBSOLETE_CACHE = "reloadcache";
	public static final String OBSOLETE_VO    = "reloadvo";
	public static final String MOC_DIR        = "MOC";
	public static final String MOC_NAME       = "MOC_collection.fits";

	/*
	public static final String CONFIG     	  = "config";
	 * These fields are set into the accessors because the class can be used before the repository is created
	 * We supposed the accessors to be called after the repository is created 
	 */
	public static String VOREPORTS_PATH      = null;
	public static String TMP_PATH            = null;
	public static String LOGS_PATH           = null;
	public static String INDEXRELATIONS_PATH = null;
	public static String EMBEDDEDDB_PATH     = null;
	public static String DMS_PATH            = null;
	public static String CONFIG_PATH         = null;
	public static String OBSOLETE_CACHE_PATH = null;
	public static String OBSOLETE_VO_PATH    = null;

	/**
	 * @return
	 */
	public static final String getVoreportsPath() {
		if( VOREPORTS_PATH == null ) 
			VOREPORTS_PATH =  Database.getRepository()
			+ separ
			+ VOREPORTS 
			+ separ;		
		return VOREPORTS_PATH;
	}
	
	/**
	 * @param sessionId User session
	 * @return          Returns the directory where data associated 
	 *                   with a user session are stored
	 */
	public static final String getUserReportsPath(String sessionId) {
		if( VOREPORTS_PATH == null ) 
			VOREPORTS_PATH =  Database.getRepository()
			+ separ
			+ VOREPORTS 
			+ separ;		
		return VOREPORTS_PATH  + sessionId + separ;
	}
	
	/**
	 * This methods allows to set the base directory where the files generated by any processing initiated by servlet
	 * (VO jobs, user sessions..) are stored.
	 * The real voreport dir is path/voreports
	 * If the given path is not valid, the repository/voreports dir is taken
	 * @param path absolute path of the base directory
	 */
	public static final void setVoreportsPath(String path){
		File f = new File(path);
		if( f.isAbsolute() && f.exists() && f.isDirectory() && f.canWrite() ){
			VOREPORTS_PATH = path + separ
			+ VOREPORTS 
			+ separ;
			Messenger.printMsg(Messenger.TRACE, "Uses " + VOREPORTS_PATH + " as vo-report directory");
		} else {
			Messenger.printMsg(Messenger.WARNING, "Cannot uses " + path + " as vo-report directory, switch back to the repository");
			VOREPORTS_PATH = null;
		}
	}
	
	/**
	 * Return the full path for the data of category in collection
	 * @param collection
	 * @param category
	 * @return
	 * @throws FatalException
	 */
	public static final String getCollectionPath(String collection , int category) throws FatalException {
		return  Database.getRepository()
		+ separ + collection
		+ separ + Category.explain(category) 
		+ separ;
	}
	/**
	 * Return the name of the MOC directory for the images of the collection.
	 * The directory availability is not checked
	 * @param collection
	 * @return
	 * @throws FatalException
	 */
	public static final String getMocDirectory(String collection) throws FatalException{
		return getCollectionPath(collection, Category.IMAGE) + MOC_DIR;
	}
	
	/**
	 * Return the path of the MOC for the images of the collection.
	 * The file availability is not checked
	 * @param collection
	 * @return
	 * @throws FatalException
	 */
	public static final String getMocCollectionMocPath(String collection) throws FatalException{
		return getCollectionPath(collection, Category.IMAGE) + MOC_DIR + separ + MOC_NAME;
	}
	
	/**
	 * Remove the whole content of the MOC directory of the images of the collection
	 * @throws FatalException 
	 */
	public static final void sweepMocDir(String collection) throws FatalException {
		Messenger.printMsg(Messenger.TRACE, "Sweeping MOC dir of collection " + collection);
		String[] content = (new File(getMocDirectory(collection))).list();
		for( String c: content) {
			Files.deleteFile(getVoreportsPath() + File.separator + c);
		}
	}
	
	/**
	 * @return
	 */
	public static final String getTmpPath() {
		if( TMP_PATH == null ) 
			TMP_PATH =  Database.getRepository()
			+ separ
			+ TMP ;		
		return TMP_PATH;
	}
	/**
	 * @return
	 */
	public static final String getLogsPath() {
		if( LOGS_PATH == null ) 
			LOGS_PATH =  Database.getRepository()
			+ separ
			+ LOGS ;	
		return LOGS_PATH;
	}
	/**
	 * @return
	 */
	public static final String getIndexrelationsPath() {
		if( INDEXRELATIONS_PATH == null ) 
			INDEXRELATIONS_PATH =  Database.getRepository()
			+ separ
			+ INDEXRELATIONS ;	
		return INDEXRELATIONS_PATH;
	}
	/**
	 * @return
	 */
	public static final String getDmsPath() {
		if( DMS_PATH == null ) 
			DMS_PATH =  Database.getRepository()
			+ separ
			+ DMS ;		
		return DMS_PATH;
	}
	/**
	 * @return
	 */
	public static final String getEmbeddeddbPath() {
		if( EMBEDDEDDB_PATH == null ) 
			EMBEDDEDDB_PATH =  Database.getRepository()
			+ separ
			+ EMBEDDEDDB ;		
		return EMBEDDEDDB_PATH;
	}
	/**
	 * @return
	 */
	public static final String getConfigPath() {
		if( CONFIG_PATH == null ) 
			CONFIG_PATH =  Database.getRepository()
			+ separ
			+ CONFIG ;		
		return CONFIG_PATH;
	}
	/**
	 * @return
	 */
	public static final String getObsoleteCachePath() {
		if( OBSOLETE_CACHE_PATH == null ) 
			OBSOLETE_CACHE_PATH = getTmpPath() 
			+ separ
			+ OBSOLETE_CACHE ;		
		return OBSOLETE_CACHE_PATH;
	}
	/**
	 * @return
	 */
	public static final String getObsoleteVOPath() {
		if( OBSOLETE_VO_PATH == null ) 
			OBSOLETE_VO_PATH = getTmpPath() 
			+ separ
			+ OBSOLETE_VO ;		
		return OBSOLETE_VO_PATH;
	}
	/**
	 *  remove VO reports  older the 30000 sec
	 * @throws DatabaseException 
	 */
	public static void cleanUpReportDir() {
		File f = new File(getVoreportsPath());
		if( f.isDirectory() ) {
			String[] content = f.list();
			long t0 = (new Date()).getTime();
			for( int i=0 ; i<content.length ; i++ ) {
				File item = new File(getVoreportsPath() + Database.getSepar() + content[i]);
				if( !item.isDirectory() ) {
					long dt = (t0 - item.lastModified())/1000;
					/*
					 * Reports are removed after 30000 seconds
					 */
					if( dt > 300000) {
						Messenger.printMsg(Messenger.TRACE, "removing VO report " + content[i] + " (" + dt + "sec old)");
						item.delete();
					}
				}
			}
		}
	}
	
	/**
	 * Remove the whole content of the report dir
	 */
	public static final void sweepReportDir() {
		Messenger.printMsg(Messenger.TRACE, "Sweeping report dir");
		String[] content = (new File(getVoreportsPath())).list();
		for( String c: content) {
			Files.deleteFile(getVoreportsPath() + File.separator + c);
		}

	}
	/**
	 * Create the file marking the cache meta has to be reloaded
	 * @throws Exception
	 */
	public static final void markObsoleteCache() throws Exception{
		File f = new File(getObsoleteCachePath());
		if( !f.exists()){
			f.createNewFile();
		}
	}
	/**
	 * Remove the file marking the cache meta has to be reloaded
	 * @throws IOException
	 */
	public static final void dropObsoleteCache() throws IOException{
		File f = new File(getObsoleteCachePath());
		if( f.exists()){
			f.delete();
		}
	}
	/**
	 * @return true if the file marking a cache meta modification exist
	 * @throws IOException
	 */
	public static boolean  isMetaMarkedAsObsolete() throws IOException{
		File f = new File(getObsoleteCachePath());
		return f.exists();
	}
	/**
	 * Create the file marking the cache VO has to be reloaded
	 * @throws Exception
	 */
	public static final void markObsoleteVO() throws Exception{
		File f = new File(getObsoleteVOPath());
		if( !f.exists()){
			f.createNewFile();
		}
	}
	/**
	 * Remove the file marking the cache VO has to be reloaded
	 * @throws IOException
	 */
	public static final void dropObsoleteVO() throws IOException{
		File f = new File(getObsoleteVOPath());
		if( f.exists()){
			f.delete();
		}
	}
	/**
	 * @return true if the file marking a cache VO modification exist
	 * @throws IOException
	 */
	public static boolean  isVOMarkedAsObsolete() throws IOException{
		File f = new File(getObsoleteVOPath());
		return f.exists();
	}

	/**
	 * @param org_file : Full path of the origin file
	 * @param dest_file : name of the destination file
	 * @param collection : collection where to store the file
	 * @param category : category where to store the file
	 * @throws Exception
	 */
	public static void storeDataFile(String org_file,String dest_file, String collection, int category) throws Exception {
		String reportFile = Database.getRepository() 
		+ separ + collection
		+ separ + Category.explain(category) 
		+ separ;
		CopyFile.copy(org_file, reportFile + dest_file);
	}
	/**
	 * @param org_file : Full path of the origin file
	 * @param dest_file : name of the destination file
	 * @param oidsaada
	 * @throws Exception
	 */
	public static void storeDataFile(String org_file,String dest_file, long oidsaada) throws Exception {
		String reportFile = Database.getRepository() 
		+ separ + SaadaOID.getCollectionName(oidsaada) 
		+ separ + SaadaOID.getCategoryName(oidsaada) 
		+ separ;
		CopyFile.copy(org_file, reportFile + dest_file);
	}


	/**
	 * Remove from the repository the directory tree of the collection coll
	 * @param coll: collection to remove
	 */
	public static void removeCollectionDir(String coll) {
		String dirname = Database.getRepository() + separ + coll;
		File dir = new File(dirname);
		if( dir.exists() ) {
			if( !Files.deleteFile(dir) ) {
				Messenger.printMsg(Messenger.WARNING, "Could not remove directory " + dirname);
			}
		}		
	}
	/**
	 * Create in the repository the directory tree for the collection coll
	 * @param coll
	 * @throws FatalException 
	 */
	public static void createSubdirsForCollection(String coll) throws FatalException {
		removeCollectionDir(coll);
		String dirname = Database.getRepository() + separ + coll;
		File dir = new File(dirname);
		if( !dir.mkdirs() ) {
			FatalException.throwNewException(SaadaException.FILE_ACCESS, "Could not create directory " + dirname);				
		}
		if( !dir.exists() || !dir.isDirectory() || !dir.canWrite() ) {
			FatalException.throwNewException(SaadaException.FILE_ACCESS, "Directory " + dirname + " has nnot been created or has no wrtite permission");				

		}
		for( int cat=1 ; cat<Category.NB_CAT ; cat++ ) {
			/*
			 * update the repository
			 */
			if( ! (new File(dirname + separ + Category.explain(cat))).mkdirs() ){
				FatalException.throwNewException(SaadaException.FILE_ACCESS, "Could not create directory " + dirname + separ + Category.explain(cat));				
			}
			if( cat == Category.IMAGE || cat == Category.SPECTRUM ) {
				if( ! (new File(dirname + separ + Category.explain(cat) + separ + "JPEG")).mkdirs()		){
					FatalException.throwNewException(SaadaException.FILE_ACCESS, "Could not create directory " + dirname + separ + Category.explain(cat)+ separ + "JPEG");				
				}			
			}
		}
	}
}
